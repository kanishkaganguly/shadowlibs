//
// Created by kganguly on 4/30/19.
//

#pragma once

#include <shadowlibs/shadow_utils.hpp>
#include <shadowlibs/shadow_planning_options.hpp>

namespace shadow_finger {
    /* Get preloaded plans for open or close */
    inline std::string getSavedStateName(std::string finger_name, std::string saved_state) {
        std::string saved_state_name;
        // "open" or "pack"
        std::size_t thumb_check = finger_name.find("thumb");
        if (thumb_check != std::string::npos)
            saved_state_name = finger_name + "_" + saved_state;
        else
            saved_state_name = finger_name + "_finger_" + saved_state;
        return saved_state_name;
    };

    /* Get planning group names */
    inline std::string getMoveGroupName(std::string finger_name) {
        std::string move_group_name;
        std::size_t thumb_check = finger_name.find("thumb");
        if (thumb_check != std::string::npos)
            move_group_name = "rh_" + finger_name;
        else
            move_group_name = "rh_" + finger_name + "_finger";

        return move_group_name;
    };

    /* Get joint names */
    inline std::vector <std::string>
    getJointNames(moveit::planning_interface::MoveGroupInterface &move_group_interface) {
        std::vector <std::string> joint_names;
        joint_names = move_group_interface.getJointNames();
        return joint_names;
    };

    inline std::vector <std::string> getJointNames(moveit::planning_interface::MoveGroupInterface::Plan &plan) {
        // This is the trajectory generated by MoveIt plan
        moveit_msgs::RobotTrajectory robotTrajectory = plan.trajectory_;
        // Convert MoveIt to trajectory_msgs joint trajectory
        trajectory_msgs::JointTrajectory planTrajectory = robotTrajectory.joint_trajectory;
        // Gives all the joint names in the planning group used when planning
        std::vector <std::string> jointNames = planTrajectory.joint_names;
        return jointNames;
    };

    inline std::vector<double> getJointValues(moveit::planning_interface::MoveGroupInterface& move_group_interface) {
        std::vector<double> joint_vals;
        joint_vals = move_group_interface.getCurrentJointValues();
        return joint_vals;
    }

    /* Get joint limits */
    inline std::vector <std::tuple<float, float>> getFingerJointLimits(std::vector <std::string> &joint_names) {
        urdf::Model model;
        if (!model.initParam("/robot_description")) {
            ROS_ERROR("Failed to parse urdf file");
        }
        ROS_INFO("Successfully parsed urdf file");
        std::vector <std::tuple<float, float>> joint_limits;
        for (auto joint_name:joint_names) {
            urdf::JointConstSharedPtr j = model.getJoint(joint_name);
            joint_limits.push_back(std::make_tuple(j->limits->upper, j->limits->lower));
        }
        return joint_limits;
    }

    /* Finger name to BioTac index */
    const static std::vector <std::string> biotac_idx = {"first", "middle", "ring", "little", "thumb"};

    inline int getBiotacIdx(std::string &finger_name) {
        int idx = -1;
        for (auto &each_idx : biotac_idx) {
            idx += 1;
            std::size_t found = finger_name.find(each_idx);
            if (found != std::string::npos) {
                return idx;
            }
        }
        return idx;
    }

    // Manage fingers using separate classes
    struct Finger {
        // NodeHandle
        ros::NodeHandle _node_handle;
        // Finger name
        std::string _finger_name;
        // BioTac ID
        int _biotac_id;
        // Set of joints in finger
        std::vector <std::string> _joint_names;
        // Joint limits (upper, lower)
        std::vector <std::tuple<float, float>> _joint_limits;
        // MoveIt planning group
        moveit::planning_interface::MoveGroupInterface _finger_move_group;
        // MoveIt plan for finger
        moveit::planning_interface::MoveGroupInterface::Plan _plan;
        // Planning options for finger
        shadow_planning::PlanningOptions _planning_options;
        // Publisher list for inner-loop controller
        std::vector <ros::Publisher> _joint_controller_publishers;

        // Minimum requirement is the finger name, everything else can be populated from there
        Finger(std::string &finger_name, ros::NodeHandle &node_handle) :
                _finger_name(finger_name),
                _finger_move_group(finger_name),
                _node_handle(node_handle) {
            _joint_names = shadow_finger::getJointNames(_finger_move_group);
            _joint_controller_publishers = shadow_utils::createJointControllerPublishers(_joint_names, _node_handle);
            _biotac_id = shadow_finger::getBiotacIdx(_finger_name);
            _joint_limits = shadow_finger::getFingerJointLimits(_joint_names);
            ROS_INFO_STREAM("Initialized Finger: " << _finger_name);
        };

        // Joint limits from joint name
        inline std::tuple<float, float> jointLimitsFromName(std::string& joint_name) {
            std::vector<std::string>::iterator it = std::find(_joint_names.begin(), _joint_names.end(), joint_name);
            if (it != _joint_names.end()) {
                int idx = std::distance(_joint_names.begin(), it);
                return _joint_limits[idx];
            } else {
                ROS_ERROR_STREAM("Joint " << joint_name << " not found in " << _finger_name << ".");
                return std::make_tuple(0.0, 0.0);
            }
        }

        struct BioTac {
            int16_t pressure;
            std::vector <int16_t> impedance;
        };

        /* BioTac related functions */
        shadow_finger::Finger::BioTac getBiotacPressure();

        shadow_finger::Finger::BioTac getBiotacImpedance();

        shadow_finger::Finger::BioTac getBiotacImpedancePressure();
    };

    /* Get joint names and values */
    inline std::vector<double> getJointValues(shadow_finger::Finger &finger) {
        std::vector<double> joint_vals;
        joint_vals = finger._finger_move_group.getCurrentJointValues();
        return joint_vals;
    }

    inline std::vector <std::string> getJointNames(shadow_finger::Finger &finger) {
        std::vector <std::string> joint_names;
        joint_names = finger._finger_move_group.getJointNames();
        return joint_names;
    };

}
